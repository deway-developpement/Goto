# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

directive @constraint(pattern: String) on FIELD_DEFINITION

type User {
  id: ID!
  pseudo: String!
  email: String!
  password: String!
  publicKey: String!
  credidential: Float!
  createdAt: DateTime!
  friendsAggregate(
    """Filter to find records to aggregate on"""
    filter: UserAggregateFilter
  ): [UserFriendsAggregateResponse!]!
  friends(
    """Specify to filter the records returned."""
    filter: UserFilter = {}

    """Specify to sort results."""
    sorting: [UserSort!] = []
  ): [User!]!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input UserAggregateFilter {
  and: [UserAggregateFilter!]
  or: [UserAggregateFilter!]
  id: IDFilterComparison
  pseudo: StringFieldComparison
  email: StringFieldComparison
  password: StringFieldComparison
  publicKey: StringFieldComparison
  credidential: NumberFieldComparison
  createdAt: DateFieldComparison
}

input IDFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ID
  neq: ID
  gt: ID
  gte: ID
  lt: ID
  lte: ID
  like: ID
  notLike: ID
  iLike: ID
  notILike: ID
  in: [ID!]
  notIn: [ID!]
}

input StringFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: String
  neq: String
  gt: String
  gte: String
  lt: String
  lte: String
  like: String
  notLike: String
  iLike: String
  notILike: String
  in: [String!]
  notIn: [String!]
}

input NumberFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: Float
  neq: Float
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  in: [Float!]
  notIn: [Float!]
  between: NumberFieldComparisonBetween
  notBetween: NumberFieldComparisonBetween
}

input NumberFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

input DateFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: DateTime
  neq: DateTime
  gt: DateTime
  gte: DateTime
  lt: DateTime
  lte: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  between: DateFieldComparisonBetween
  notBetween: DateFieldComparisonBetween
}

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

input UserFilter {
  and: [UserFilter!]
  or: [UserFilter!]
  id: IDFilterComparison
  pseudo: StringFieldComparison
  email: StringFieldComparison
  password: StringFieldComparison
  publicKey: StringFieldComparison
  credidential: NumberFieldComparison
  createdAt: DateFieldComparison
}

input UserSort {
  field: UserSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum UserSortFields {
  id
  pseudo
  email
  password
  publicKey
  credidential
  createdAt
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

type UserAggregateGroupBy {
  id: ID
  pseudo: String
  email: String
  password: String
  publicKey: String
  credidential: Float
  createdAt: DateTime
}

type UserCountAggregate {
  id: Int
  pseudo: Int
  email: Int
  password: Int
  publicKey: Int
  credidential: Int
  createdAt: Int
}

type UserSumAggregate {
  credidential: Float
}

type UserAvgAggregate {
  credidential: Float
}

type UserMinAggregate {
  id: ID
  pseudo: String
  email: String
  password: String
  publicKey: String
  credidential: Float
  createdAt: DateTime
}

type UserMaxAggregate {
  id: ID
  pseudo: String
  email: String
  password: String
  publicKey: String
  credidential: Float
  createdAt: DateTime
}

type UserAggregateResponse {
  groupBy: UserAggregateGroupBy
  count: UserCountAggregate
  sum: UserSumAggregate
  avg: UserAvgAggregate
  min: UserMinAggregate
  max: UserMaxAggregate
}

type UserFriendsAggregateGroupBy {
  id: ID
  pseudo: String
  email: String
  password: String
  publicKey: String
  credidential: Float
  createdAt: DateTime
}

type UserFriendsCountAggregate {
  id: Int
  pseudo: Int
  email: Int
  password: Int
  publicKey: Int
  credidential: Int
  createdAt: Int
}

type UserFriendsSumAggregate {
  credidential: Float
}

type UserFriendsAvgAggregate {
  credidential: Float
}

type UserFriendsMinAggregate {
  id: ID
  pseudo: String
  email: String
  password: String
  publicKey: String
  credidential: Float
  createdAt: DateTime
}

type UserFriendsMaxAggregate {
  id: ID
  pseudo: String
  email: String
  password: String
  publicKey: String
  credidential: Float
  createdAt: DateTime
}

type UserFriendsAggregateResponse {
  groupBy: UserFriendsAggregateGroupBy
  count: UserFriendsCountAggregate
  sum: UserFriendsSumAggregate
  avg: UserFriendsAvgAggregate
  min: UserFriendsMinAggregate
  max: UserFriendsMaxAggregate
}

type tag {
  id: ID!
  name: String!
  createdAt: DateTime!
  hikes(
    """Specify to filter the records returned."""
    filter: HikeFilter = {}

    """Specify to sort results."""
    sorting: [HikeSort!] = []
  ): [Hike!]
}

input HikeFilter {
  and: [HikeFilter!]
  or: [HikeFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  distance: NumberFieldComparison
  elevation: NumberFieldComparison
  difficulty: DifficultyFilterComparison
  duration: NumberFieldComparison
  createdAt: DateFieldComparison
  tags: HikeFiltertagFilter
}

input DifficultyFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: Difficulty
  neq: Difficulty
  gt: Difficulty
  gte: Difficulty
  lt: Difficulty
  lte: Difficulty
  like: Difficulty
  notLike: Difficulty
  iLike: Difficulty
  notILike: Difficulty
  in: [Difficulty!]
  notIn: [Difficulty!]
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

input HikeFiltertagFilter {
  and: [HikeFiltertagFilter!]
  or: [HikeFiltertagFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  createdAt: DateFieldComparison
}

input HikeSort {
  field: HikeSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum HikeSortFields {
  id
  name
  distance
  elevation
  difficulty
  duration
  createdAt
}

type Hike {
  id: ID!
  name: String!
  distance: Float!
  elevation: Float!
  description: String!
  difficulty: Difficulty!
  duration: Float
  track: String!
  createdAt: DateTime!
  owner: User!
  tags(
    """Specify to filter the records returned."""
    filter: tagFilter = {}

    """Specify to sort results."""
    sorting: [tagSort!] = []
  ): [tag!]
  photos: [String!]!
}

input tagFilter {
  and: [tagFilter!]
  or: [tagFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  createdAt: DateFieldComparison
}

input tagSort {
  field: tagSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum tagSortFields {
  id
  name
  createdAt
}

type HikeAggregateGroupBy {
  id: ID
  name: String
  distance: Float
  elevation: Float
  difficulty: Difficulty
  duration: Float
  createdAt: DateTime
}

type HikeCountAggregate {
  id: Int
  name: Int
  distance: Int
  elevation: Int
  difficulty: Int
  duration: Int
  createdAt: Int
}

type HikeSumAggregate {
  distance: Float
  elevation: Float
  duration: Float
}

type HikeAvgAggregate {
  distance: Float
  elevation: Float
  duration: Float
}

type HikeMinAggregate {
  id: ID
  name: String
  distance: Float
  elevation: Float
  difficulty: Difficulty
  duration: Float
  createdAt: DateTime
}

type HikeMaxAggregate {
  id: ID
  name: String
  distance: Float
  elevation: Float
  difficulty: Difficulty
  duration: Float
  createdAt: DateTime
}

type HikeAggregateResponse {
  groupBy: HikeAggregateGroupBy
  count: HikeCountAggregate
  sum: HikeSumAggregate
  avg: HikeAvgAggregate
  min: HikeMinAggregate
  max: HikeMaxAggregate
}

type tagAggregateGroupBy {
  id: ID
  name: String
  createdAt: DateTime
}

type tagCountAggregate {
  id: Int
  name: Int
  createdAt: Int
}

type tagMinAggregate {
  id: ID
  name: String
  createdAt: DateTime
}

type tagMaxAggregate {
  id: ID
  name: String
  createdAt: DateTime
}

type Query {
  userAggregate(
    """Filter to find records to aggregate on"""
    filter: UserAggregateFilter
  ): [UserAggregateResponse!]!
  user(
    """The id of the record to find."""
    id: ID!
  ): User
  users(
    """Specify to filter the records returned."""
    filter: UserFilter = {}

    """Specify to sort results."""
    sorting: [UserSort!] = []
  ): [User!]!
  exist(email: String!): Boolean!
  hikeAggregate(
    """Filter to find records to aggregate on"""
    filter: HikeAggregateFilter
  ): [HikeAggregateResponse!]!
  hike(
    """The id of the record to find."""
    id: ID!
  ): Hike
  hikes(
    """Specify to filter the records returned."""
    filter: HikeFilter = {}

    """Specify to sort results."""
    sorting: [HikeSort!] = []
  ): [Hike!]!
  tag(
    """The id of the record to find."""
    id: ID!
  ): tag
  tags(
    """Specify to filter the records returned."""
    filter: tagFilter = {}

    """Specify to sort results."""
    sorting: [tagSort!] = []
  ): [tag!]!
}

input HikeAggregateFilter {
  and: [HikeAggregateFilter!]
  or: [HikeAggregateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  distance: NumberFieldComparison
  elevation: NumberFieldComparison
  difficulty: DifficultyFilterComparison
  duration: NumberFieldComparison
  createdAt: DateFieldComparison
}

type Mutation {
  createUser(input: UserInput!): User!
  updateUser(id: String!, input: UserUpdateInput!): User!
  addFriend(id: String!): User!
  removeFriend(id: String!): User!
  deleteAccount: User!
  createHike(input: HikeInput!): Hike!
  addTagToHike(hikeId: String!, tagId: String!): Hike!
  removeTagFromHike(hikeId: String!, tagId: String!): Hike!
  removeHike(id: String!): Hike!
  createTag(input: TagInput!): tag!
  removeTag(id: String!): tag!
}

input UserInput {
  """Pseudo of the user"""
  pseudo: String!

  """E-mail of the user"""
  email: String!

  """Password of the user"""
  password: String!
}

input UserUpdateInput {
  """Pseudo of the user"""
  pseudo: String

  """E-mail of the user"""
  email: String

  """Password of the user"""
  password: String
}

input HikeInput {
  name: String!
  distance: Float!
  elevation: Float!
  description: String!
  difficulty: Difficulty!
  track: Upload!
  tagsId: [String!]!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input TagInput {
  name: String!
}
